Explain $ARGUMENTS using first principles and computational thinking:

## The Four Components

### 1. Decomposition: Break It Down
- **What problem does this solve?** (The fundamental "why does this exist?")
- **What came before it?** What naive approach does this improve upon?
- **What are the subproblems?** Break the concept into its atomic pieces

### 2. Pattern Recognition: Connect the Dots
- **Which of the 26 patterns does this belong to?**
- **What other problems use this same technique?**
- **Key signals**: What phrases in a problem hint at using this?

### 3. Abstraction: The Core Insight
- **What's the "aha" moment?** The key insight that makes this work
- **Strip away the noise**: What's the minimum you need to understand?

### 4. Algorithm Design: How It Works
- **Minimal working example** (10-20 lines max in Python)
- **Walk through with concrete small input** (n=3-5)
- **Visual if helpful**: ASCII diagram for trees/graphs/pointers

## Trade-off Analysis (The Third Pillar)

| Aspect | This Approach | Alternative |
|--------|---------------|-------------|
| Time | O(?) | O(?) |
| Space | O(?) | O(?) |
| When better | [scenario] | [scenario] |

## Decision Framework
- **When to use**: [specific scenarios]
- **When NOT to use**: [anti-patterns, edge cases where it fails]
- **Common mistakes**: [pitfalls to avoid]

## Analogies
Use: football tactics (formations = data structures), web dev (caching = memoization, load balancing = partitioning)

Example: "Binary search is like a football scout narrowing down player options - instead of watching all 1000 players, you eliminate half each round based on criteria"
